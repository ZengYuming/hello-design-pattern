# hello-design-pattern
设计模式学习笔记，此项目参考《大话设计模式》，只能作为入门级设计模式学习

## 设计原则
### 职责单一原则
### 开放-封闭原则
### 依赖倒转原则
高层模块不依赖底层模块，两个模块都应该依赖抽象。抽象不依赖细节，细节依赖抽象。针对接口编程，不要针对实现编程
### 里氏代换原则
子类型必须能够替换掉它们的父类型。
### 迪米特法则
也叫最少知识原则。公司电脑坏了，是找IT部还是IT部的某个人？如果那个人不在怎么办？ 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接关系。如果其中一个类需要调用另一个类的方法，可以通过第三者转发这个调用。
强调松耦合
### 聚合/合成复用原则

## 设计模式
### simple-factory 简单工厂模式
在工厂类中用switch分支生成对象
优点：工厂类中包含了判断逻辑，根据客户端选择动态实例化相关的类，去除了与具体产品的依赖。
### strategy 策略模式
它定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。
所有算法都是完成相同的工作，只是各个算法的实现不同，外部可以用相同的方式调用所有的算法，减少了算法类和使用算法类之间的耦合。
如果需要在不同时间应用不同的业务规则，就可以考虑使用策略模式来处理这种变化。
### decorator 装饰模式
为已有功能（或对象）添加更多功能的一种方式。它吧每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，客户端可以根据需要有选择的，按顺序的使用装饰功能包装对象。
优点：把装饰功能从类中分离，使核心职责得到独立。
### proxy 代理模式
为其他对象提供一种代理以控制对这个对象的访问。
### factory-method 工厂方法模式
定义了一个用于创建对象的接口，让子类决定实例化哪一个类。使类实例化延迟到其子类。
### prototype 原型模式
用原型实例指定创建对象的种类。让一个原型克隆自身从而创建一个新的对象。
从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。
原型模型的浅复制，相当于Clone，只复制（被复制对象的第一层）结构和数据，不复制对象的（第二层）属性对象的数据
原型模型的深复制，相当于Copy，结构和数据都复制。
### template 模版方法模式
定义一个操作中的算法骨架，而组成骨架的一个一个具体算法将延迟到子类中实现。模版模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
就像试卷一样，之前没有印刷机的时候，是同学们自己抄老师出的考题然后作答的。这样容易出错，后来有了印刷机，就只要写一个试卷模版，然后拿去印刷，发给同学们，这就是模版模式。
当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，可以使用模版模式。
模版方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。
当不变和可变行为在方法的子类实现中混合在一起时，不变行为就会在子类中重复出现。通过模版方法模型把这些行为搬到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。
### facade 外观模式
为子系统中的一组接口提供一个一致的接口，此模式定义了一个高层接口，这个接口使子系统更加容易使用。
在设计初期，可以有意识的用外观模式进行架构分层，比如经典的三层模型就是用外观模式。
在开放阶段，重构带来的复杂度，可以用外观模式提供一个简单接口，以减少外部调用的复杂度。
在维护阶段，遗留系统可能难维护和扩展，用外观模式和遗留代码交互所有复杂工作。
### builder 建造者模式（生成器模式）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
如果需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，可以使用建造者模式。
建造者模式需要一个指挥者类，用于封装建造者的构建过程（步骤调用），这个构建过程通常是稳定的。
何时使用？当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。
### observer 观察者模式
定义类一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。主题对象状态变化时，通知所有观察者对象，使它们能够自己更新自己。
解决了什么问题？
将一个系统分割成一系列相互协作的类，需要维护它们直接的一致性。但是我们又不希望它们发生耦合。观察者模式就解决了这个问题。
其实就是解除耦合，耦合的双方依赖于抽象，从而使得各自变化不会影响另一方的变化。
何时使用？
当一个对象发生改变时，需要同时改变其他对象，并且不知道具体有多少对象需要改变时。可以使用观察者模式。
观察者模式的不足？
单纯的观察者模式是用"主题Subject"+"观察者Observer"组成的，但是很多现实情况，可能不方便继承观察者接口，比如那些早就封装好的类。还有就是当触发改变时，每个具体的观察者可能要执行的方法都不一样。
简单来说，就是尽管已经符合依赖倒转原则，但是"抽象通知者"还是依赖"抽象观察者"，万一没有"抽象观察者"这样的接口，那么通知就完成不了了。
另外，就是每个观察者，它不一定是调用update方法，现实中哪有这么多同名方法。
所以需要事件委托实现，在客户端来决定通知谁
观察者模式如果不使用委托，就面临着观察者需要通过实现接口来统一update方法。这对于已经封装完成的功能来说，要求过于苛刻。
所谓观察者模式：指的是在某种情况下需要同时触发一系列相关操作，它存在观察者和通知者两个概念，通知者持有观察者的抽象类的集合，可以调用所有观察者的特定方法以更新状态，同时观察者也可持有通知者的抽象对象以获取具体通知者的特有信息。
观察者模式的不足：虽然观察者模式提取出了抽象观察者和通知者，让类与类之间不互相依赖，共同依赖于抽象接口，符合依赖倒转，但他任需要依赖于抽象接口，而且有些时候观察者无法继承抽象观察者（比如引用jar包）。
java委托机制与观察者模式：委托机制的实现不再需要观察者抽象类，观察者和通知者互不依赖。java利用反射即可实现
### 抽象工厂模式
### 状态模式
### 适配器模式
### 备忘录模式
### 组合模式
### 迭代器模式
### 单例模式
### 桥接模式
### command 命令模式
什么是？将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。对请求排队或记录请求日志，以及支持可撤销的操作。
优点？
1.便于设计一个命令队列 
2.便于将执行的命令记入日志 
3.允许接收请求的一方决定是否要否决请求。
4.可以容易的实现对请求的撤销和重做
5.把请求操作对象和执行操作对象分割开，解藕。
### chain of responsibility 职责链模式
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
优点？
当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。这使得接收者和发送者都不用知道对方的详情信息，
且链中的对象自己也并不知道链的结构。这就简化链对象的相互连接，它们只需要保持一个向后指的引用，且不需保持它所有的候选接受者的引用，这就降低链耦合度。
链的结构在客户端定义，所以可以随时增加或修改处理一个请求的链结构，增强了给对象指派职责的灵活性。
### mediator 中介者模式（调停者模式）
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。
优点？
1.Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator
2.由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度(比如，站在联合国的角度去看各个国家)去看待系统
缺点？
由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。
何时使用？
1.一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，比如web页面的aspx控制各个控件之间的交互，而控件之间是不知道对方存在的。
2.以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。
### flyweight 享元模式
运用共享技术有效地支持大量细粒度的对象。
内部状态：在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态
外部状态：随环境改变而改变的，不可以共享的状态就是外部状态。
何时使用？
1.如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；
2.还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。
现实中的例子：
1. .net中，两个字面量相同的string对象，它们用Object.ReferenceEquals()比较，发现是同一个引用。这就是用了享元模式
2.再比如，一款围棋游戏软件，如果按常规面向对象方式编程，那么将有361个棋子对象产生，如果是多玩家，那么一台服务器就会浪费很多资源生产棋子对象。
如果用享元模式来处理，那么棋子对象就可以减少到两个实例，其他的都做成外部状态（比如用户，方位坐标）。
缺点：
1.使用享元模式需要维护一个记录了系统已有的所有享元的列表，而这本身需要耗费资源
2.另外，享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部话，这使得程序的逻辑复杂化。
所以，应当在有足够多的对象实例可供共享时，才值得使用享元模式。
### interpreter 解释器模式
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
现实中的例子：
1.正则表达式，解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式。
何时使用？
当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。
优点？
容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展文法。

### 访问者模式






